### 深拷贝与浅拷贝的区别？

**什么拷贝构造函数？**

同一个类的对象在内存中有完全相同的结构，如果作为一个整体进行复制或称拷贝是完全可行的。

这个拷贝过程只需要拷贝数据成员，而函数成员是共用的（只有一份拷贝）。在建立对象时可用同一类的另一个对象来初始化该对象的存储空间，这时所用的构造函数称为拷贝构造函数。

**深拷贝与浅拷贝的区别？**

首先简单的理解就是：

假如B复制A，如果改变A，则B也被改变，就是浅拷贝

假如B复制A，A改变，则B不变，就是深拷贝。

更深层的理解：

> 对于浅拷贝来说，只是增加了一个指针指向已经存在的内存。当浅拷贝复制引用属性时，仅仅复制指针值，没有复制指向的对象。
>
> 对于深拷贝来讲，它完成复制一份该属性指向的对象。即就是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向新的内存。

 接下来通过代码展示深拷贝和浅拷贝的区别：

```c++
#include<stdio.h>
class Mystring
{
private:
       char* str;
public:
      Mystring(const Mystring& ms):str(ms.str) //浅拷贝
      {}       
 
       Mystring(const char* p=nullptr):str(nullptr)  //深拷贝
       {
           if(p!=nullptr)
           {
              int len=strlen(p)+1;
              str=new char[len];    //使用new申请内存空间
              strcpy_s(str,len,p);
            }
        } 
 
       ~Mytring()  //析构函数
       {
           if(str!=nullptr)  
           {
                delete []str;
           }
       }
};
```

### 默认生成的构造函数是什么拷贝？

c++默认的拷贝构造函数是浅拷贝

### 什么时候使用深拷贝？

当深拷贝发生时，通常表明存在着一个“聚合关系”，而浅拷贝发生时，通常表明存在着一个“相识关系”。  

举个简单的例子：  

> 当你实现一个Composite  Pattern，你通常都会实现一个深拷贝(如果需要拷贝的话)，很少有要求同的Composite共享Leaf的；  
>
> 而当你实现一个Observer  Pattern时，如果你需要拷贝Observer，你大概不会去拷贝Subject，这时就要实现个浅拷贝。  
>
> 是深拷贝还是浅拷贝，并不是取决于时间效率、空间效率或是语言等等，而是取决于哪一个是逻辑上正确的。  
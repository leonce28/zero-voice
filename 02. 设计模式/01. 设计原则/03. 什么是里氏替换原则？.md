### 里氏替换原则

里氏替换原则，英文名Liskov Substitution Principle，它的定义是

> 如果对每一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有对象o1都替换成o2的时候，程序P的行为都没有发生变化，那么类型T2是类型T1的子类型。

看起来有点绕口，它还有一个简单的定义：

> 所有引用基类的地方必须能够透明地使用其子类的对象。

通俗点说，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何异常。 但是反过来就不行了，因为子类可以扩展父类没有的功能，同时子类还不能改变父类原有的功能。

我们都知道，面向对象的三大特征是封装、继承和多态，这三者缺一不可，但三者之间却并不 “和谐“。

因为继承有很多缺点，当子类继承父类时，虽然可以复用父类的代码，但是父类的属性和方法对子类都是透明的，子类可以随意修改父类的成员。

如果需求变更，子类对父类的方法进行了一些复写的时候，其他的子类可能就需要随之改变，这在一定程度上就违反了封装的原则，解决的方案就是引入里氏替换原则。

里氏替换原则为良好的继承定义了一个规范，它包含了4层含义：

**含义一：**子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。

**含义二：**子类可以有自己的个性，可以有自己的属性和方法。

**含义三：**子类覆盖或重载父类的方法时输入参数可以被放大。

比如父类有一个方法，参数是HashMap

```java
public class Father {
    public void test(HashMap map){
        System.out.println("父类被执行。。。。。");
    }
}
```


那么子类的同名方法输入参数的类型可以扩大，例如我们输入参数为Map，

```java
public class Son extends Father{
    public void test(Map map){
        System.out.println("子类被执行。。。。");
    }
}我们写一个场景类测试一下父类的方法执行效果，
```

```java
public class Client {
    public static void main(String[] args) {
        Father father = new Father();
        HashMap map = new HashMap();
        father.test(map);
    }
}
```

结果输出：`父类被执行。。。。。`

因为里氏替换原则，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何异常。我们改下代码，调用子类的方法，

```java
public class Client {
    public static void main(String[] args) {
        Son son = new Son();
        HashMap map = new HashMap();
        father.test(map);
    }
}
```

运行结果是一样的，因为子类方法的输入参数类型范围扩大了，子类代替父类传递到调用者中，子类的方法永远不会被执行，这样的结果其实是正确的，如果想让子类方法执行，可以重写方法体。

反之，如果子类的输入参数类型范围比父类还小，比如父类中的参数是Map，而子类是HashMap，那么执行上述代码的结果就会是子类的方法体。

有人说，这难道不对吗？子类显示自己的内容啊。其实这是不对的，因为子类没有复写父类的同名方法，方法就被执行了，这会引起逻辑的混乱，如果父类是抽象类，子类是实现类，你传递一个这样的实现类就违背了父类的意图了，容易引起逻辑混乱，所以子类覆盖或重载父类的方法时输入参数必定是相同或者放大的。

**含义四：**子类覆盖或重载父类的方法时输出结果可以被缩小，也就是说返回值要小于或等于父类的方法返回值。

确保程序遵循里氏替换原则可以要求我们的程序建立抽象，通过抽象去建立规范，然后用实现去扩展细节，所以，它跟开闭原则往往是相互依存的。
### 线程阻塞

**哪些情况线程会被阻塞？什么是线程阻塞？**

在某一时刻某一个线程在运行一段代码的时候，这时候另一个线程也需要运行，但是在运行过程中的那个线程执行完成之前，另一个线程是无法获取到CPU执行权的，这个时候就会造成线程阻塞。

**为什么会出现线程阻塞？**

1. 睡眠状态：当一个线程执行代码的时候调用了sleep方法后，线程处于睡眠状态，需要设置一个睡眠时间，此时有其他线程需要执行时就会造成线程阻塞，而且sleep方法被调用之后，线程不会释放锁对象，也就是说锁还在该线程手里，CPU执行权还在自己手里，等睡眠时间一过，该线程就会进入就绪状态，典型的“占着茅坑不拉屎”；

2. 等待状态：当一个线程正在运行时，调用了wait方法，此时该线程需要交出CPU执行权，也就是将锁释放出去，交给另一个线程，该线程进入等待状态，但与睡眠状态不一样的是，进入等待状态的线程不需要设置睡眠时间，但是需要执行notify方法或者notifyall方法来对其唤醒，自己是不会主动醒来的，等被唤醒之后，该线程也会进入就绪状态，但是进入仅需状态的该线程手里是没有执行权的，也就是没有锁，而睡眠状态的线程一旦苏醒，进入就绪状态时是自己还拿着锁的。等待状态的线程苏醒后，就是典型的“物是人非，大权旁落“；

3. 礼让状态：当一个线程正在运行时，调用了yield方法之后，该线程会将执行权礼让给同等级的线程或者比它高一级的线程优先执行，此时该线程有可能只执行了一部分而此时把执行权礼让给了其他线程，这个时候也会进入阻塞状态，但是该线程会随时可能又被分配到执行权，这就很”中国化的线程“了，比较讲究谦让；

4. 自闭状态：当一个线程正在运行时，调用了一个join方法，此时该线程会进入阻塞状态，另一个线程会运行，直到运行结束后，原线程才会进入就绪状态。这个比较像是”走后门“，本来该先把你的事情解决完了再解决后边的人的事情，但是这时候有走后门的人，那就会停止给你解决，而优先把走后门的人事情解决了；

5. suspend() 和 resume() ：这两个方法是配套使用的，suspend() 是让线程进入阻塞状态，它的解药就是resume()，没有resume()它自己是不会恢复的，由于这种比较容易出现死锁现象，所以jdk1.5之后就已经被废除了，这对就是相爱相杀的一对。

导致阻塞的原因有很多种，大致分为三种来讨论，分别是一般线程中的阻塞，Socket客户端的阻塞，Socket服务器端的阻塞。

------

**一般线程中的阻塞：**

1. 线程执行了Thread.sleep(int millsecond);方法，当前线程放弃CPU，睡眠一段时间，然后再恢复执行
2. 线程执行一段同步代码，但是尚且无法获得相关的同步锁，只能进入阻塞状态，等到获取了同步锁，才能回复执行。
3. 线程执行了一个对象的wait()方法，直接进入阻塞状态，等待其他线程执行notify()或者notifyAll()方法。
4. 线程执行某些IO操作，因为等待相关的资源而进入了阻塞状态。比如说监听system.in，但是尚且没有收到键盘的输入，则进入阻塞状态。

**Socket客户端的阻塞：**

1. 请求与服务器连接时，调用connect方法，进入阻塞状态，直至连接成功。
2. 当从Socket输入流读取数据时，在读取足够的数据之前会进入阻塞状态。比如说通过BufferedReader类使用readLine()方法时，在没有读出一行数据之前，数据量就不算是足够，会处在阻塞状态下。
3. 调用Socket的setSoLinger()方法关闭了Socket延迟，当执行Socket的close方法时，会进入阻塞状态，知道底层Socket发送完所有的剩余数据

**Socket服务器的阻塞：**

1. 线程执行ServerSocket的accept()方法，等待客户的连接，知道接收到客户的连接，才从accept方法中返回一个Socket对象
2. 从Socket输入流读取数据时，如果输入流没有足够的数据，就会进入阻塞状态
3. 线程向Socket的输出流写入一批数据，可能进入阻塞状态

----

当程序阻塞时，会降低程序的效率，于是人们就希望能引入非阻塞的操作方法。   

所谓非阻塞方法，就是指当线程执行这些方法时，如果操作还没有就绪，就立即返回，不会阻塞着等待操作就绪。